Graphics vs Logic: Movement Type

Directly after this project began, Logic and Graphics started creating different forms of movement, unbeknowest to the opposing team. From the onset, both groups created code for a solution that the other group was not prepared to handle, leading to the biggest breakdown of communication to come out of this project, and the greatest problem we had to face as a group.

Once this problem was uncovered, nearly half way to the project deadline, an emergency meeting took place where every class member had to cast their vote to determine the movement type to be used. Both the Logic team leader Curtis, and the Graphics team leader Colby, presented the class with their argument for each of their respective positions. 

Logic argued to represent movement as 2D grids filled with values representing to represent players moving, bombs exploding, and walls. Using this method made game logic simpler in theory, allowing collision detection to be a simple check of the grid to see if it contained a wall or bomb. Player movements would have been sent as a value for the grid space, and the location of the grid space, thus only two changes needed to be made for a player moving one square: The value of the square moved into, and the new value of the square moved out of, to now represent an empty space.

Ultimately, Graphics won the vote, in favour of having "fluid" graphical movement instead of grid based movement, and having to send less information overall from clients to server back to clients. This pretty much tipped Logic upside down, and new methods had to be created to allow what Logic had started to mingle properly with what graphics had envisioned.

Perfect Plan vs Reality:

Having learned our lesson in the previous term's final assignment, our class started out fired up, and ready to conquer this project. For the initial three weeks of this project, our class spent literally all of our time in mass debates about what project we should choose, why we should choose said project, and finally, what we need to do for the chosen project. Once Tux Bomber was decided on, and with very high hopes, our class organized a very structured and prestine schedule of incremental deadlines. Once our class was broken into it's three main groups (Logic, Graphics and Network), we gave each group's team leader the task of schedule internal deadlines. The class as a whole, was given 3 integration deadlines in the hopes that each group would have met their deadlines, and for each integration period, the project would be compilable to represent set goals. This is not what happened...

As time went on, Tux Bomber was constantly transfigured to exist within pockets of free work time. Per week, we had allocated four hours of in-class work time, and sure enough, this turned out to be much less time than was needed to complete each groups deadlines. Even with our best intentions, as more and more external assignments piled up, our progress halted.  The deadline for Tux Bomber continued to feel safely, far away. Bomberman did not take a forefront. Further and further past the first integration period, it became apparent that we made a crucial oversight, and that we should have been integrating everything from day one. By letting each group break off into their own world, we effectively crippled our productivity when the time came to integrate. As it stands now, we have yet to have ever completed Integration period #1.